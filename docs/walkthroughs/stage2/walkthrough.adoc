:toc:
:toc-placement!:

= Lab 2 - Gitter to Slack bridge (bi-directional)

toc::[]

== Overview
Lab 1 enabled a Gitter to Slack data flow. On this second lab we want the flow to work in both directions so that users from both chat platforms can exchange messages and have a conversation.

Difficulty level: +

* *EASY*

Target persona: +

* *Kubernetes User*

{empty} +

[NOTE]
--
Given the first lab covered in detail the workflows for both personas, consider yourself well equipped with the knowledge and tools to choose your preferred methodology going forward.

From now on, we simplify the instructions with code snippets directly deployable in OpenShift. Feel free to modify the snippets accordingly if you'd like to test them locally (as a Camel expert). 
--

{empty} +

The picture billow illustrates two data flows interconnecting both chat systems, one for each direction of communication:

// image::images/processing-flow.png[title="Data flow",align="center",title-align=center, width=80%]
image::images/data-flow.png[align="center", width=80%]

Luckily for us, we've already done all the necessary onboarding setup with both chat systems, so this lab should be a lot faster to complete than the first one.

{empty} +

== Create the integration flows

=== Gitter to Slack

This process is identical to the one you've already created in Lab 1, except there is situation you need to prevent. Ask ourself the following:

* If the App in a room fires an event for each new message in a conversation, what would happen when interconnecting both Apps?

Obviously, the interaction between both platforms would enter in a ping-pong effect between the App in Gitter and the App in Slack.

image::images/death-loop.png[align="center", width=60%]

A filtering mechanism needs to be put in place to prevent the interaction from entering in a death loop.

{empty} +

==== Process overview

The diagram below illustrates the processing flow you're about to create:

image::images/processing-flow-g2s.png[align="center", width=80%]


* There are 4 Kamelets in use:
+
====
A source::
consumes events from Gitter.
Two actions::
one filters messages to prevent death loops. +
one transforms Gitter events to Slack events (in JSON format).
A sink::
	produces events to Slack.
====

{empty} +

You can tell from the list above that this second lab suits very well the _Kubernetes_ user persona: all the integration process involves is defining a _Kamelet Binding_ with a sequence of _Kamelets_ in them.

{empty} +

==== Process definition

. Create the skeleton
+
Using the sources of _Stage1_ as a base, make a copy of your previous exercise, and rename all occurrences of `stage1` to `stage2`.

. Include the filter
+
The challenge with Gitter, contrary to other chat platforms, is that there's no field (within the incoming event) indicating if the message is from a human or an app. To distinguish one from the other, we need to come up with a pattern that works for us.
+
--
Given our JSLT converts messages to the following pattern:

* `username@system:`  message
--
+
It makes sense to use the same pattern to identify and block incoming events since we know they are app-generated by Camel's JSLT transformation.
+
There is a convenient Kamelet in the _Catalog_ that works for us:
+
--
* `predicate-filter-action`
+
Reference:: https://camel.apache.org/camel-kamelets/0.8.x/predicate-filter-action.html
--
This _Kamelet_ action applies a jsonpath expression where we can use a regular expression operator to match the blocking pattern. 
+
With all the above in mind, let's include a `filter-action` Kamelet that does just what's needed. Copy the filter snippet below and paste it in your Kamelet Binding:
+
----
apiVersion: camel.apache.org/v1alpha1
kind: KameletBinding
metadata:
  name: g2s
  annotations:
    trait.camel.apache.org/mount.configs: "secret:stage2"
    trait.camel.apache.org/mount.resources: "configmap:stage2-transform"
spec:

  source:
    ref:
      kind: Kamelet
      apiVersion: camel.apache.org/v1
      name: gitter-source
    properties:
      token: "{{gitter.token}}"
      room:  "{{gitter.room}}"

  steps:
----
+
```yaml
  # Filter BOT messages
  # Bot message pattern is: [username@system: message text] -->
  - ref:
      kind: Kamelet
      apiVersion: camel.apache.org/v1
      name: predicate-filter-action
    properties:
      expression: $.text =~ /(?!\*\*.*@.*\*\*:).*/
```
+
----
  - ref:
      kind: Kamelet
      apiVersion: camel.apache.org/v1
      name: jslt-action
    properties:
      template: g2s.jslt

  sink:
    ref:
      kind: Kamelet
      apiVersion: camel.apache.org/v1
      name: slack-sink
    properties:
      token: "{{slack.token}}"
----
+
In the filter above you'll notice the expression is picking the `text` JSON field and matching it with the regular expression that takes in account the _Markdown_ syntax that Gitter uses.
+
{empty} + 

. Push the configuration to _OpenShift_
+
Create Stage2's corresponding _ConfigMap_ and _Secret_. +
Run the following `oc` command:
+
```bash
oc create cm stage2-transform --from-file=g2s.jslt
oc create secret generic stage2 --from-file=stage2.properties

```
{empty} +

. Deploy the YAML definition containing your new Kamelet Binding
.. Run the following `oc` command to deploy the integration:
+
```bash
oc apply -f g2s.yaml
```
+
NOTE: Be patient, this action will take some time to complete as the operator needs to download all the filter's maven dependencies, build the application and create the image before the integration can be deployed.

.. Check your deployment
+
Check the pod's deployment and logs to ensure all is in healthy state.
+
{empty} +

. Send a message from Gitter
+
Now, from Gitter's chat room, send a message, for example "Hello Camel".
+
The logs in your pod should show the arrival of a Gitter event similar to the following JSON payload:
+
```json
{"id":"6318848405ad4a3701dccfb4","text":"Hello Camel","html":"Hello Camel","sent":"2022-09-07T11:46:12.825Z","readBy":0,"urls":[],"mentions":[],"issues":[],"meta":[],"v":1,"fromUser":{"id":"xxxxxxxxxxxxxxxx","username":"demo-user"         }}
```
+
Hopefully you've been successful in capturing Gitter messages with Camel. +
+
{empty} +

